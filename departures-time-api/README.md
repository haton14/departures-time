# Departures Time API
## 技術について
### 使用したもの
#### 開発
- Go 1.18 (一番慣れ親しんだ言語です)
- devcontainer(Docker)
- GitHub Actions
- [echo v5](https://echo.labstack.com/v5/guide/) (普段はv4を使用しています)
- [gomock](https://github.com/golang/mock) (普段からunit testを書くのに使用しています)
- [testify](https://github.com/stretchr/testify) (普段から使用しています)
#### インフラ
- ECS Fargate (API実行環境)
- Route 53 (SSL証明書発行&ドメイン設定)
- ALB (本来の用途に加えSSL証明書を簡単につけるため)
- Certificate Manager (SSL証明書発行)
- ECR (ビルド済みDockerイメージの保存場所)

### 技術的な選択
- クリーンアーキテクチャと値オブジェクトを使用することに意識を置いています
  - handler(controller)はWebフレームワークを使用する限り依存してしまうので抽象化は行っていないです
  - 厳密にはルーティング処理も抽象化すべきですが個人的には`main.go`に具体的に書いたほうがわかりやすいのでそうしています
  - 値オブジェクトを作成し適切なコメントを追記すれば仕様をきちんと管理できます
- エラーは全てhandlerまで何が起きたのかわかるようにラップした上で、ロギングをhandlerで行なっています
  - エラーが起きた時点でスタックトレースログを出力するパターンもありますが、Goでは十分な情報をつけた上でラップすれば充分なケースがほとんどです
    - 公式がメンテしているプロダクトコードのエラー処理参考として、[pkg.go.dev](https://cs.opensource.google/go/x/pkgsite/+/master:internal/auth/auth.go;l=46)を見ています
- CIを設定しています
  - build, lint, testをプルリク作成時に行います go.sumをもとにキャッシュすることでできるだけ高速化しています
- CDを設定しています
  - プルリクがマージされたらDockerイメージをビルドし、ECRにプッシュするようにしています
  - プルリク作成時にテストは行なっているので不要です

### 改善点
- 結合テストやE2Eテストが実際のプロダクトでは必要です
- 公開APIに同じパラメータでアクセスするならばキャッシュするべきです
- externalのテストはモックサーバを立ち上げて外部サービスに依存することなる異常系を含めて行うべきです
  - 正常系は本物のAPIにアクセスして挙動が変わっていないか確認するべきだと思っています
- handlerにもテストは追加するべきです
  - 今回はひとりで開発しているのでフロントとの結合を持って確認したことにしています
- 公開APIにアクセスする際には明示的にタイムアウトを設定すべきです
- デプロイのパイプラインを設定すべきです
  - 実際のプロダクト開発では手動でデプロイを行うには手順書を作成しなくてはならずコストがかかります
  - CodeBuild, CodePipelineを使用して作成できますが今回は時間がありませんでした
- インフラをTerraformでコード管理したほうが差分がわかりやすいです
- CORS対応を厳密に行うべきです
- OpenAPIドキュメントからGoのhandlerコードを生成したほうが効率がいいかもしれません(特に規模が大きい場合)
- いつ公開APIが停止するか分からないので、公開APIではなく官公庁の公開データをフォーマットしてDBに取り込んだ方が良いです
